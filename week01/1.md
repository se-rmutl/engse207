เนื้อหาการสอนรายสัปดาห์ (ฉบับขยาย)
ENGSE207 สถาปัตยกรรมซอฟต์แวร์ (Software Architecture)สัปดาห์ที่ 1: บทนำสถาปัตยกรรมซอฟต์แวร์และภาพรวมระบบสมัยใหม่วัตถุประสงค์

เข้าใจนิยาม บทบาท และความสำคัญของสถาปัตยกรรมซอฟต์แวร์
แยกความแตกต่างระหว่าง Architecture vs Design vs Implementation
ศึกษาตัวอย่างสถาปัตยกรรมของระบบยอดนิยมจากอุตสาหกรรม
เนื้อหาภาคทฤษฎี (2 ชั่วโมง)1. ความหมายของสถาปัตยกรรมซอฟต์แวร์

นิยามตาม IEEE 1471: โครงสร้างพื้นฐานของระบบ องค์ประกอบหลัก ความสัมพันธ์ระหว่างองค์ประกอบ และหลักการที่ใช้ในการออกแบบและวิวัฒนาการของระบบ
บทบาทของสถาปัตยกรรม:

เป็นพิมพ์เขียวสำหรับการพัฒนาระบบ
เชื่อมโยง Business Requirements กับ Technical Implementation
เป็นเครื่องมือสื่อสารระหว่าง Stakeholders
ช่วยในการตัดสินใจเชิงเทคนิคที่สำคัญ


2. ความแตกต่างระหว่าง Architecture, Design และ Implementation

Architecture: การตัดสินใจระดับสูงที่ส่งผลกระทบต่อระบบทั้งหมด (High-level structure)

ตัวอย่าง: เลือกใช้ Microservices หรือ Monolithic
ผลกระทบ: ยากต่อการเปลี่ยนแปลง มีต้นทุนสูง



Design: การออกแบบในระดับโมดูล คลาส และส่วนประกอบย่อย

ตัวอย่าง: ออกแบบ Class Diagram, Database Schema
ผลกระทบ: เปลี่ยนแปลงได้ง่ายกว่า Architecture



Implementation: การเขียนโค้ดและรายละเอียดการทำงานจริง

ตัวอย่าง: เลือกใช้ Algorithm, เขียน Business Logic
ผลกระทบ: เปลี่ยนแปลงได้ง่ายที่สุด


3. Stakeholders และมุมมองของสถาปัตยกรรม

ผู้มีส่วนได้ส่วนเสีย (Stakeholders):

นักพัฒนา (Developers)
ผู้บริหารโครงการ (Project Managers)
ผู้ดูแลระบบ (Operations/DevOps)
ผู้ใช้งาน (End Users)
เจ้าของธุรกิจ (Business Owners)
นักวิเคราะห์ความปลอดภัย (Security Analysts)



Views และ Viewpoints:

Functional View: แสดงการทำงานของระบบ
Deployment View: แสดงการติดตั้งและโครงสร้างทางกายภาพ
Development View: แสดงโครงสร้างโค้ดและการจัดการโมดูล
Process View: แสดง Runtime behavior และ concurrency


4. ตัวอย่างสถาปัตยกรรมจากอุตสาหกรรม

ระบบสตรีมมิ่ง (เช่น Netflix):

Microservices Architecture
Content Delivery Network (CDN)
Recommendation Engine
Video Encoding Pipeline



ระบบแชท (เช่น LINE, Discord):

Real-time messaging architecture
WebSocket connections
Message Queue systems
Presence and notification services



ระบบอีคอมเมิร์ซ (เช่น Shopee, Lazada):

Order Management System
Payment Gateway Integration
Inventory Management
Search and Recommendation


เนื้อหาภาคปฏิบัติ (3 ชั่วโมง)กิจกรรมกลุ่ม: "วิเคราะห์ระบบที่คุ้นเคย"วัตถุประสงค์: ให้นักศึกษาฝึกมองระบบจริงในมุมของสถาปัตยกรรมซอฟต์แวร์ขั้นตอนการทำกิจกรรม:

แบ่งกลุ่ม (15 นาที)

แบ่งนักศึกษาเป็นกลุ่มละ 4-5 คน
ให้แต่ละกลุ่มเลือกระบบที่คุ้นเคย เช่น:

LINE (Messaging App)
Shopee/Lazada (E-Commerce)
YouTube (Video Streaming)
Grab/Bolt (Ride-hailing)
Instagram (Social Media)





วิเคราะห์ระบบ (60 นาที)

ระบุองค์ประกอบหลักของระบบ (Major Components)
วาดแผนภาพกล่องใหญ่ ๆ แสดง System Context
ระบุ External Systems ที่เชื่อมต่อ
คิดเกี่ยวกับ Users และ Use Cases หลัก ๆ



Workshop และอภิปราย (80 นาที)

แต่ละกลุ่มนำเสนอระบบที่เลือก (10 นาที/กลุ่ม)
อภิปรายร่วมกัน:

ทำไมระบบนี้ต้องมีองค์ประกอบเหล่านี้?
คุณลักษณะคุณภาพอะไรสำคัญสำหรับระบบนี้?
ความท้าทายในการออกแบบสถาปัตยกรรมคืออะไร?





สรุปบทเรียน (25 นาที)

อาจารย์สรุปแนวคิดสำคัญ
เชื่อมโยงกับเนื้อหาที่จะเรียนในสัปดาห์ถัดไป


ผลลัพธ์ที่คาดหวัง:

แผนภาพ System Context แบบไม่เป็นทางการ
รายการ Stakeholders และความต้องการหลัก
ความเข้าใจเบื้องต้นเกี่ยวกับ Architectural Components



สัปดาห์ที่ 2: Quality Attributes & Architectural Driversวัตถุประสงค์

เข้าใจและระบุ Quality Attributes ที่สำคัญของระบบซอฟต์แวร์
เรียนรู้การเขียน Quality Attribute Scenarios
เข้าใจแนวคิด Architectural Drivers และ Trade-offs
เนื้อหาภาคทฤษฎี (2 ชั่วโมง)1. Quality Attributes คืออะไร

นิยาม: คุณลักษณะที่วัดคุณภาพของระบบซอฟต์แวร์ นอกเหนือจากการทำงานตามฟังก์ชัน (Non-functional Requirements)
ความสำคัญ: มีผลต่อการตัดสินใจออกแบบสถาปัตยกรรมโดยตรง
2. Quality Attributes หลัก ๆA. Performance (ประสิทธิภาพ)

คำจำกัดความ: ความเร็วและประสิทธิภาพในการตอบสนองต่อคำขอ
ตัวชี้วัด:

Response Time (เวลาตอบสนอง)
Throughput (ปริมาณงานที่ประมวลผลได้ต่อหนึ่งหน่วยเวลา)
Latency (ความล่าช้า)


ตัวอย่าง: ระบบต้องตอบสนองภายใน 200ms สำหรับ 95% ของคำขอ
B. Scalability (ความสามารถในการขยายตัว)

คำจำกัดความ: ความสามารถในการรองรับโหลดที่เพิ่มขึ้น
ประเภท:

Vertical Scaling (เพิ่มทรัพยากรเครื่องเดิม)
Horizontal Scaling (เพิ่มจำนวนเครื่อง)


ตัวอย่าง: ระบบต้องรองรับผู้ใช้เพิ่มจาก 1,000 เป็น 100,000 คน
C. Availability (ความพร้อมใช้งาน)

คำจำกัดความ: เปอร์เซ็นต์เวลาที่ระบบพร้อมให้บริการ
ตัวชี้วัด:

Uptime (99.9%, 99.99%, 99.999%)
MTBF (Mean Time Between Failures)
MTTR (Mean Time To Recovery)


ตัวอย่าง: ระบบต้องมี Uptime 99.9% (downtime ไม่เกิน 8.76 ชั่วโมง/ปี)
D. Reliability (ความน่าเชื่อถือ)

คำจำกัดความ: ความสามารถในการทำงานอย่างถูกต้องและสม่ำเสมอ
ตัวชี้วัด:

Error Rate
Failure Rate
Data Integrity


ตัวอย่าง: ระบบการชำระเงินต้องประมวลผลธุรกรรมถูกต้อง 100%
E. Security (ความปลอดภัย)

คำจำกัดความ: การปกป้องระบบและข้อมูลจากการเข้าถึงโดยไม่ได้รับอนุญาต
มิติสำคัญ:

Confidentiality (ความลับ)
Integrity (ความสมบูรณ์)
Availability (ความพร้อมใช้)
Authentication & Authorization


ตัวอย่าง: ข้อมูลส่วนบุคคลต้องเข้ารหัสและเข้าถึงได้เฉพาะผู้มีสิทธิ์
F. Modifiability (ความสามารถในการดัดแปลง)

คำจำกัดความ: ความง่ายในการเปลี่ยนแปลงและเพิ่มฟีเจอร์ใหม่
ตัวชี้วัด:

เวลาในการเพิ่มฟีเจอร์ใหม่
จำนวนโมดูลที่ต้องแก้ไข
ความเสี่ยงของการเกิด Bug


ตัวอย่าง: สามารถเพิ่มช่องทางการชำระเงินใหม่ได้ภายใน 2 วัน
G. Usability (ความใช้งานง่าย)

คำจำกัดความ: ความง่ายในการใช้งานของระบบ
ตัวชี้วัด:

เวลาในการเรียนรู้การใช้งาน
ความพึงพอใจของผู้ใช้
Error Rate ของผู้ใช้


ตัวอย่าง: ผู้ใช้ใหม่สามารถทำธุรกรรมแรกได้สำเร็จภายใน 5 นาที
H. Testability (ความสามารถในการทดสอบ)

คำจำกัดความ: ความง่ายในการทดสอบระบบ
ตัวชี้วัด:

Code Coverage
เวลาในการรัน Test Suite
ความสามารถใน Automated Testing


ตัวอย่าง: Test Suite ครอบคลุมโค้ด 80% และรันเสร็จภายใน 10 นาที
3. Quality Attribute Scenariosโครงสร้างของ Scenario:
| ส่วนประกอบ | คำอธิบาย | ตัวอย่าง |
|------------|----------|----------|
| Source | ผู้หรือสิ่งที่กระตุ้นเหตุการณ์ | ผู้ใช้, ระบบภายนอก, Administrator |
| Stimulus | เหตุการณ์ที่เกิดขึ้น | การส่งคำขอ, การเกิด Error, การโจมตี |
| Environment | สภาวะของระบบขณะเกิดเหตุการณ์ | Normal operation, Peak load, Under attack |
| Artifact | ส่วนของระบบที่ได้รับผลกระทบ | Server, Database, API Gateway |
| Response | การตอบสนองของระบบ | ส่งข้อมูลกลับ, Log error, Block request |
| Response Measure | ค่าที่วัดได้ของการตอบสนอง | เวลา 200ms, Uptime 99.9%, 0 data loss |ตัวอย่าง Quality Attribute Scenario:Scenario 1: Performance

Source: ผู้ใช้งาน
Stimulus: ส่งคำขอค้นหาสินค้า
Environment: ระบบทำงานปกติ มีผู้ใช้ 1,000 คนพร้อมกัน
Artifact: Search Service
Response: ระบบส่งผลการค้นหากลับ
Response Measure: ภายในเวลา 200 มิลลิวินาทีสำหรับ 95% ของคำขอ
Scenario 2: Availability

Source: Server Hardware
Stimulus: เซิร์ฟเวอร์หลักเสียหาย
Environment: ระบบทำงานในช่วงเวลาปกติ
Artifact: Web Application
Response: ระบบสลับไปใช้ Backup Server อัตโนมัติ
Response Measure: ระบบกลับมาทำงานได้ภายใน 30 วินาที, Downtime ไม่เกิน 30 วินาที
Scenario 3: Security

Source: Hacker
Stimulus: พยายาม SQL Injection attack
Environment: ระบบทำงานปกติ
Artifact: Database Access Layer
Response: ระบบปฏิเสธคำขอและบันทึก Log
Response Measure: Block request ภายใน 10ms, แจ้งเตือน Security Team ภายใน 1 นาที
4. Architectural Driversคำจำกัดความ: Quality Attributes และ Constraints ที่มีผลกระทบสำคัญต่อการตัดสินใจออกแบบสถาปัตยกรรมองค์ประกอบของ Architectural Drivers:

Functional Requirements: สิ่งที่ระบบต้องทำ
Quality Attributes: คุณลักษณะคุณภาพที่ต้องการ
Technical Constraints: ข้อจำกัดด้านเทคนิค
Business Constraints: ข้อจำกัดด้านธุรกิจ
ตัวอย่าง Architectural Drivers:

"ระบบต้องรองรับผู้ใช้ 100,000 คนพร้อมกัน" → มีผลต่อการเลือก Scalability pattern
"ระบบต้องมี Uptime 99.99%" → มีผลต่อการออกแบบ High Availability
"งบประมาณจำกัดอยู่ที่ 500,000 บาท" → มีผลต่อการเลือกเทคโนโลยีและ Cloud Provider
5. Trade-offs ในสถาปัตยกรรมแนวคิด: ไม่มีสถาปัตยกรรมใดที่ "สมบูรณ์แบบ" ทุกอย่าง - ต้องเลือกสิ่งที่สำคัญที่สุดและยอมแลกกับสิ่งอื่นตัวอย่าง Trade-offs:Quality Attribute 1↔️Quality Attribute 2คำอธิบายPerformancevsModifiabilityโค้ดที่ Optimize เกินไปมักแก้ไขยากScalabilityvsCostระบบที่ Scale ได้ดีมักมีค่าใช้จ่ายสูงSecurityvsUsabilitySecurity ที่เข้มงวดอาจลดความสะดวกในการใช้งานConsistencyvsAvailabilityตาม CAP Theorem ไม่สามารถได้ทั้งสองอย่างพร้อมกัน 100%SimplicityvsFlexibilityระบบที่ง่ายอาจมีความยืดหยุ่นน้อยเนื้อหาภาคปฏิบัติ (3 ชั่วโมง)Workshop: เขียน Quality Attribute Scenarios สำหรับ "Cloud-based Task Board System"ระบบที่จะออกแบบ: ระบบจัดการงาน (Task Board) แบบ Cloud-based คล้าย Trello, Asana หรือ Jiraคุณสมบัติหลักของระบบ:

ผู้ใช้สามารถสร้าง Board, List, และ Task Card
ลากวาง Task Card ระหว่าง List
มอบหมายงานให้สมาชิกในทีม
แสดงความคืบหน้าของโปรเจกต์
แจ้งเตือนเมื่อมีการเปลี่ยนแปลง
รองรับการทำงานหลายคนพร้อมกัน
ขั้นตอนการทำ Workshop:ส่วนที่ 1: Brainstorming (30 นาที)

แบ่งกลุ่มย่อย 4-5 คน
ให้แต่ละกลุ่ม Brainstorm Quality Attributes ที่สำคัญสำหรับระบบนี้
ใช้ Sticky Notes เขียน Quality Attributes ที่คิดได้
ส่วนที่ 2: จัดลำดับความสำคัญ (30 นาที)

รวมผล Brainstorming จากทุกกลุ่ม
ใช้วิธี Dot Voting เพื่อเลือก Top 5 Quality Attributes ที่สำคัญที่สุด
ผลที่คาดหวัง เช่น:

Performance (Real-time collaboration)
Availability (ใช้งานได้ตลอดเวลา)
Scalability (รองรับทีมขนาดต่าง ๆ)
Security (ปกป้องข้อมูลโปรเจกต์)
Usability (ใช้งานง่าย)


ส่วนที่ 3: เขียน Quality Attribute Scenarios (90 นาที)

แบ่งกลุ่มออกเป็น 5 กลุ่ม แต่ละกลุ่มรับผิดชอบ 1 Quality Attribute
ใช้แบบฟอร์ม Scenario Template เขียนอย่างน้อย 3 Scenarios
นำเสนอ Scenarios ที่เขียนต่ออาจารย์และเพื่อน ๆ
ตัวอย่าง Scenarios ที่นักศึกษาอาจเขียน:Performance Scenario 1:
Source: ผู้ใช้งาน
Stimulus: ลากวาง Task Card จาก List หนึ่งไปยังอีก List หนึ่ง
Environment: มีผู้ใช้ 5 คนกำลังดู Board เดียวกัน
Artifact: Task Board Interface
Response: การเปลี่ยนแปลงแสดงผลบนหน้าจอของผู้ใช้ทุกคน
Response Measure: ภายในเวลา 100ms, สำหรับ 99% ของกรณีAvailability Scenario 1:
Source: Cloud Provider
Stimulus: Data Center ในภูมิภาคหนึ่งล่ม
Environment: ระบบทำงานในช่วงเวลาทำงาน (9-18 น.)
Artifact: Entire System
Response: ระบบสลับไปใช้ Data Center ในภูมิภาคสำรอง
Response Measure: Downtime ไม่เกิน 1 นาที, ข้อมูลไม่สูญหายSecurity Scenario 1:
Source: ผู้ใช้ภายนอกที่ไม่มีสิทธิ์
Stimulus: พยายามเข้าถึง Board ของทีมอื่น
Environment: ผู้ใช้ไม่ได้ Login หรือไม่ได้เป็นสมาชิกของทีม
Artifact: API Gateway, Authentication Service
Response: ปฏิเสธการเข้าถึงและบันทึก Log
Response Measure: Block ภายใน 10ms, บันทึก Log พร้อม IP addressส่วนที่ 4: ระบุ Architectural Drivers (30 นาที)

รวบรวม Scenarios ที่สำคัญที่สุด
ระบุ Architectural Drivers หลัก ๆ เช่น:

"ระบบต้องรองรับ Real-time collaboration"
"ระบบต้องมี Availability 99.9%"
"ระบบต้องรองรับทีมขนาด 5-500 คน"
"ระบบต้องปกป้องข้อมูลโปรเจกต์จากการเข้าถึงโดยไม่ได้รับอนุญาต"
"งบประมาณในการพัฒนาจำกัดอยู่ที่ 1 ล้านบาท"


ผลลัพธ์ที่คาดหวัง:

นักศึกษาเข้าใจวิธีเขียน Quality Attribute Scenarios
ได้ชุด Scenarios สำหรับ Task Board System ที่จะใช้ตลอดเทอม
เห็นความเชื่อมโยงระหว่าง Quality Attributes กับ Architectural Decisions
สัปดาห์ที่ 3: Architectural Styles & Patterns (1) - Monolith, Layered, Client-Server, N-Tier, Pipe-and-Filterวัตถุประสงค์

เข้าใจ Architectural Styles พื้นฐานและการนำไปใช้
วิเคราะห์ข้อดี-ข้อเสียของแต่ละ Style
ประยุกต์ใช้ Patterns กับระบบจริง
เนื้อหาภาคทฤษฎี (2 ชั่วโมง)1. Monolithic Architectureคำจำกัดความ: สถาปัตยกรรมที่รวมทุกส่วนของระบบไว้ใน Codebase และ Deployment Unit เดียวลักษณะเด่น:

โค้ดทั้งหมดอยู่ใน Repository เดียว
Deploy เป็น Unit เดียว (เช่น .war, .jar, .exe)
Database เดียว (ส่วนใหญ่)
ทุก Component ทำงานใน Process เดียวกัน
ข้อดี:

เรียบง่าย: เหมาะกับทีมเล็กและระบบไม่ซับซ้อน
พัฒนาเร็ว: ในช่วงเริ่มต้นไม่ต้องออกแบบ Integration ซับซ้อน
ทดสอบง่าย: Run และ Test ได้ใน Environment เดียว
Deploy ง่าย: Copy file เดียวไปติดตั้ง
Performance ดี: ไม่มี Network overhead จากการเรียกข้าม Service
ข้อเสีย:

Scalability จำกัด: Scale ทั้งระบบไปพร้อมกัน ไม่สามารถ Scale เฉพาะส่วนที่ Load สูง
แก้ไขยาก: เมื่อระบบใหญ่ขึ้น Code coupling สูง
Deployment Risk: การ Deploy ส่งผลกระทบทั้งระบบ
Technology Lock-in: ติดกับ Technology Stack เดียว
ทีมทำงานยาก: หลายทีมทำงาน Codebase เดียวกัน เกิด Conflict
เหมาะกับ:

Startup หรือโปรเจกต์เล็ก
ระบบที่ Requirements ชัดเจนและไม่ซับซ้อน
ทีมพัฒนาขนาดเล็ก (< 10 คน)
ระบบที่ไม่ต้องการ Scale แบบ Independent
ตัวอย่างการใช้งาน:

Web Application ทั่วไป (Blog, CMS)
Internal Tools
ระบบขนาดเล็กถึงกลาง
2. Layered Architecture (N-Layer)คำจำกัดความ: แบ่งระบบเป็นชั้น (Layer) ที่มีหน้าที่แยกจากกันชัดเจน แต่ละชั้นสื่อสารกับชั้นถัดไปเท่านั้นโครงสร้างทั่วไป:
┌─────────────────────────────────┐
│   Presentation Layer (UI)      │  ← User Interface
├─────────────────────────────────┤
│   Business Logic Layer          │  ← Business Rules, Workflows
├─────────────────────────────────┤
│   Data Access Layer (DAL)       │  ← Database Operations
├─────────────────────────────────┤
│   Database                      │  ← Data Storage
└─────────────────────────────────┘หลักการสำคัญ:

Separation of Concerns: แยกหน้าที่ชัดเจน
Dependency Rule: Layer บนพึ่งพา Layer ล่าง แต่ไม่สามารถกลับกัน
Closed Layer: ต้องผ่านทุก Layer ตามลำดับ
Layered Variations:A. 3-Tier Architecture:
┌────────────────┐
│  Presentation  │  ← Web Browser, Mobile App
├────────────────┤
│  Application   │  ← Business Logic Server
├────────────────┤
│  Data          │  ← Database Server
└────────────────┘B. Clean Architecture / Hexagonal:
          ┌────────────────┐
          │  Frameworks &  │
          │   Drivers      │
          │  (UI, DB, API) │
          └───────┬────────┘
                  │
          ┌───────▼────────┐
          │ Interface      │
          │ Adapters       │
          └───────┬────────┘
                  │
          ┌───────▼────────┐
          │ Application    │
          │ Business Rules │
          └───────┬────────┘
                  │
          ┌───────▼────────┐
          │ Entities       │
          │ (Core Domain)  │
          └────────────────┘ข้อดี:

แยกหน้าที่ชัดเจน: ง่ายต่อการจัดการและทำความเข้าใจ
Reusable: Business Logic สามารถใช้ซ้ำได้
Testable: Test แต่ละ Layer แยกกันได้
Maintainable: แก้ไข UI โดยไม่กระทบ Business Logic
เหมาะกับทีมใหญ่: แบ่งทีมตาม Layer ได้
ข้อเสีย:

Performance Overhead: ต้องผ่านหลาย Layer
Over-engineering: อาจซับซ้อนเกินไปสำหรับระบบเล็ก
Coupling between Layers: แม้แยก Layer แล้วยัง Couple กันอยู่
Database-centric: มักออกแบบรอบ Database Schema
เหมาะกับ:

Enterprise Applications
ระบบที่มี Business Logic ซับซ้อน
ทีมพัฒนาหลายทีม
ต้องการ Maintainability สูง
ตัวอย่างการใช้งาน:

ERP Systems
Banking Applications
E-Commerce Platforms
3. Client-Server Architectureคำจำกัดความ: แบ่งระบบเป็น 2 ส่วนหลัก Client (ผู้ขอบริการ) และ Server (ผู้ให้บริการ)โครงสร้าง:
┌─────────┐          ┌─────────┐
│ Client  │  ◄────►  │ Server  │
│  (UI)   │  Request │ (Logic/ │
│         │  Response│  Data)  │
└─────────┘          └─────────┘ประเภท Client-Server:A. Thin Client:

Client มีหน้าที่แสดงผลเท่านั้น
Logic อยู่ที่ Server ทั้งหมด
ตัวอย่าง: Web Application, Terminal
B. Thick Client (Fat Client):

Client มี Business Logic บางส่วน
ลด Load ของ Server
ตัวอย่าง: Desktop Applications
C. Rich Client:

Client มี UI และ Logic ที่ซับซ้อน
เชื่อมต่อ Server ผ่าน API
ตัวอย่าง: Modern Single Page Applications
ข้อดี:

Centralized Management: จัดการ Data และ Logic ที่ Server
Easy Maintenance: อัปเดต Server โดยไม่ต้องอัปเดต Client ทุกเครื่อง
Resource Sharing: หลาย Client ใช้ Resource ของ Server ร่วมกัน
Security: ควบคุม Security ที่ Server ได้ง่าย
ข้อเสีย:

Single Point of Failure: ถ้า Server ล่มระบบทั้งหมดล่ม
Network Dependency: ต้องพึ่งพา Network
Server Bottleneck: Load สูงอาจทำให้ Server ทำงานช้า
Scalability Challenge: ต้องเพิ่มกำลังของ Server
เหมาะกับ:

Web Applications
Database Applications
Email Systems
4. N-Tier Architectureคำจำกัดความ: ขยายจาก Client-Server โดยแบ่งระบบเป็น N ชั้น ที่แยกออกเป็นเครื่อง (Physical Tier) ที่ต่างกันโครงสร้างทั่วไป (3-Tier):
┌──────────────┐
│ Presentation │  ← Web Server (IIS, Apache)
│     Tier     │
└──────┬───────┘
       │ HTTP
┌──────▼───────┐
│ Application  │  ← App Server (Tomcat, Node.js)
│     Tier     │
└──────┬───────┘
       │ SQL
┌──────▼───────┐
│    Data      │  ← Database Server (MySQL, PostgreSQL)
│    Tier      │
└──────────────┘ความแตกต่างระหว่าง Layer กับ Tier:

Layer: แยกตาม Logical ใน Code
Tier: แยกตาม Physical Deployment (เครื่องคนละตัว)
ข้อดี:

Scalability: Scale แต่ละ Tier แยกอิสระกันได้
Load Distribution: กระจาย Load ไปยังหลาย Server
Fault Isolation: ปัญหาที่ Tier หนึ่งไม่กระทบ Tier อื่น
Technology Diversity: ใช้ Technology ต่างกันแต่ละ Tier ได้
ข้อเสีย:

Complexity: ซับซ้อนกว่า Monolith
Network Latency: การสื่อสารข้าม Tier มี Latency
Cost: ต้องจัดการหลาย Server
Deployment: Deploy ซับซ้อนกว่า Single Tier
เหมาะกับ:

Enterprise Applications ขนาดใหญ่
ระบบที่ต้องการ Scalability สูง
ระบบที่มี Load แตกต่างกันแต่ละ Tier
5. Pipe-and-Filter Architectureคำจำกัดความ: ประมวลผลข้อมูลผ่านลำดับของ Components (Filters) ที่เชื่อมต่อกันด้วย Pipesโครงสร้าง:
Input → [Filter 1] → [Filter 2] → [Filter 3] → Output
        ↓ Pipe 1  ↓ ↓ Pipe 2  ↓ ↓ Pipe 3  ↓แนวคิดหลัก:

Filter: Component ที่ประมวลผลข้อมูล (แปลง, กรอง, เพิ่ม)
Pipe: ช่องทางส่งข้อมูลระหว่าง Filters
Independent Filters: แต่ละ Filter ทำงานอิสระ ไม่รู้จักกัน
Data Transformation: ข้อมูลผ่านการแปลงในแต่ละ Filter
ตัวอย่างการใช้งาน:A. Compiler:
Source Code → [Lexical Analyzer] → [Parser] → [Code Generator] → ExecutableB. Data Processing Pipeline:
Raw Data → [Extract] → [Transform] → [Load] → Database (ETL)C. Image Processing:
Image → [Resize] → [Apply Filter] → [Compress] → [Save]D. Unix/Linux Commands:
bashcat file.txt | grep "error" | sort | uniq | wc -lข้อดี:

Reusability: แต่ละ Filter ใช้ซ้ำได้
Modifiability: เปลี่ยน/เพิ่ม Filter ได้ง่าย
Concurrency: Filters สามารถทำงานพร้อมกันได้
Testability: Test แต่ละ Filter แยกกัน
Simplicity: เข้าใจง่าย ตรงไปตรงมา
ข้อเสีย:

Performance: Data Transformation ซ้ำซ้อนอาจช้า
Error Handling: ยากในการจัดการ Error ที่เกิดกลางทาง
Batch Processing: เหมาะกับ Batch มากกว่า Interactive
Shared State: ไม่เหมาะถ้าต้องการ Shared State
เหมาะกับ:

Data Processing Systems
Compilers และ Interpreters
Batch Processing
Stream Processing
เนื้อหาภาคปฏิบัติ (3 ชั่วโมง)กิจกรรม: "Refactor สถาปัตยกรรมจาก Monolith → Layered"วัตถุประสงค์: ให้นักศึกษาเข้าใจการแปลง Monolithic Architecture เป็น Layered ArchitectureScenario: Task Board System เริ่มต้นด้วย Monolithic แบบง่าย ๆส่วนที่ 1: วิเคราะห์ Monolith (45 นาที)Initial Monolithic Design:
TaskBoardApp (Single Application)
├── index.html (UI)
├── script.js (All Logic + API Calls)
├── database.js (Direct DB Access)
└── server.js (HTTP Server)Code ตัวอย่าง (แบบ Monolith):
javascript// server.js - ทุกอย่างรวมกัน
const express = require('express');
const mysql = require('mysql');
const app = express();

// Database Connection
const db = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'taskboard'
});

// API Endpoint - ผสม UI, Logic, Data Access
app.get('/tasks', (req, res) => {
  // Business Logic + Data Access รวมกัน
  db.query('SELECT * FROM tasks', (error, results) => {
    if (error) throw error;
    res.json(results);
  });
});

app.post('/tasks', (req, res) => {
  const { title, description } = req.body;
  
  // Validation + Business Logic + Data Access รวมกัน
  if (!title) {
    return res.status(400).json({ error: 'Title required' });
  }
  
  db.query(
    'INSERT INTO tasks (title, description) VALUES (?, ?)',
    [title, description],
    (error, result) => {
      if (error) throw error;
      res.json({ id: result.insertId, title, description });
    }
  );
});กิจกรรม: ให้นักศึกษาระบุปัญหาของ Monolith นี้

UI, Logic, Data Access ผสมกัน
ไม่สามารถ Test แยกส่วนได้
แก้ไข Business Logic ต้องแตะ Data Access
ไม่สามารถเปลี่ยน Database ได้ง่าย
ส่วนที่ 2: ออกแบบ Layered Architecture (60 นาที)กิจกรรมกลุ่ม: แบ่งกลุ่มออกแบบ Layered ArchitectureTarget Layered Design:
┌────────────────────────────────┐
│   Presentation Layer           │
│   (React/Vue Frontend)         │
│   - Task Board UI              │
│   - Task Card Components       │
└───────────┬────────────────────┘
            │ HTTP API
┌───────────▼────────────────────┐
│   Application Layer (API)      │
│   - Express REST API           │
│   - Route Handlers             │
│   - Input Validation           │
└───────────┬────────────────────┘
            │ Service Calls
┌───────────▼────────────────────┐
│   Business Logic Layer         │
│   (Services)                   │
│   - TaskService                │
│   - UserService                │
│   - BoardService               │
└───────────┬────────────────────┘
            │ Repository Pattern
┌───────────▼────────────────────┐
│   Data Access Layer            │
│   (Repositories)               │
│   - TaskRepository             │
│   - UserRepository             │
└───────────┬────────────────────┘
            │ SQL Queries
┌───────────▼────────────────────┐
│   Database Layer               │
│   - MySQL/PostgreSQL           │
└────────────────────────────────┘Code ตัวอย่าง (แบบ Layered):javascript// Data Access Layer - TaskRepository.js
class TaskRepository {
  constructor(dbConnection) {
    this.db = dbConnection;
  }
  
  async findAll() {
    return new Promise((resolve, reject) => {
      this.db.query('SELECT * FROM tasks', (error, results) => {
        if (error) reject(error);
        resolve(results);
      });
    });
  }
  
  async create(task) {
    return new Promise((resolve, reject) => {
      this.db.query(
        'INSERT INTO tasks (title, description) VALUES (?, ?)',
        [task.title, task.description],
        (error, result) => {
          if (error) reject(error);
          resolve({ id: result.insertId, ...task });
        }
      );
    });
  }
}

// Business Logic Layer - TaskService.js
class TaskService {
  constructor(taskRepository) {
    this.taskRepository = taskRepository;
  }
  
  async getAllTasks() {
    return await this.taskRepository.findAll();
  }
  
  async createTask(taskData) {
    // Business Validation
    if (!taskData.title || taskData.title.trim() === '') {
      throw new Error('Task title is required');
    }
    
    if (taskData.title.length > 200) {
      throw new Error('Task title is too long');
    }
    
    // Business Logic
    const task = {
      title: taskData.title.trim(),
      description: taskData.description || '',
      createdAt: new Date(),
      status: 'TODO'
    };
    
    return await this.taskRepository.create(task);
  }
}

// Application Layer - taskRoutes.js
const express = require('express');
const router = express.Router();

// Dependency Injection
function createTaskRoutes(taskService) {
  router.get('/tasks', async (req, res) => {
    try {
      const tasks = await taskService.getAllTasks();
      res.json(tasks);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  
  router.post('/tasks', async (req, res) => {
    try {
      const task = await taskService.createTask(req.body);
      res.status(201).json(task);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  });
  
  return router;
}

// Main Application Setup
const taskRepository = new TaskRepository(dbConnection);
const taskService = new TaskService(taskRepository);
const taskRoutes = createTaskRoutes(taskService);
app.use('/api', taskRoutes);ส่วนที่ 3: เปรียบเทียบและวิเคราะห์ (45 นาที)กิจกรรม: ให้แต่ละกลุ่มเขียนตารางเปรียบเทียบAspectMonolithLayeredSeparation of Concerns❌ รวมกันหมด✅ แยกชัดเจนTestability❌ ยากมาก✅ Test แต่ละ Layer ได้Modifiability❌ แก้อย่างกระทบอย่าง✅ แก้ Layer เดียวReusability❌ ใช้ซ้ำยาก✅ Service ใช้ซ้ำได้Development Speed (Initial)✅ เร็วมาก❌ ช้ากว่าDevelopment Speed (Long-term)❌ ช้าลง✅ เร็วขึ้นComplexity✅ เรียบง่าย❌ ซับซ้อนกว่าPerformance✅ ไม่มี Overhead❌ มี Layer Overheadคำถามสำหรับอภิปราย:

เมื่อไหร่ควรใช้ Monolith เมื่อไหร่ควรใช้ Layered?
ถ้าระบบเล็กมาก (เช่น Todo List ส่วนตัว) จำเป็นต้อง Layered ไหม?
Layered Architecture แก้ปัญหา Scalability ได้ไหม? (ตอบ: ไม่ได้โดยตรง - ยัง Deploy เป็น Unit เดียว)
ส่วนที่ 4: Hands-on Lab (30 นาที)กิจกรรม: วาดแผนภาพ Layered Architecture สำหรับ Task Board Systemเครื่องมือ: Draw.io, Lucidchart, หรือ กระดาษขั้นตอน:

วาดแผนภาพ 5 Layers
ระบุ Components ในแต่ละ Layer
แสดง Dependencies ระหว่าง Layers (ลูกศรชี้ไปทาง Layer ล่าง)
ระบุ Design Patterns ที่ใช้ (เช่น Repository Pattern, Service Pattern)
ตัวอย่างผลลัพธ์:
┌─────────────────────────────────────┐
│ Presentation Layer                  │
│ - React Frontend                    │
│ - Components: TaskCard, BoardView   │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│ API Layer (REST/GraphQL)            │
│ - Express.js Routes                 │
│ - Input Validation Middleware       │
│ - Authentication Middleware         │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│ Business Logic Layer                │
│ - TaskService                       │
│ - BoardService                      │
│ - UserService                       │
│ - NotificationService               │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│ Data Access Layer                   │
│ - TaskRepository                    │
│ - BoardRepository                   │
│ - UserRepository                    │
│ - ORM (Sequelize/TypeORM)           │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│ Database                            │
│ - PostgreSQL                        │
│ - Tables: tasks, boards, users      │
└─────────────────────────────────────┘ผลลัพธ์ที่คาดหวัง:

นักศึกษาเห็นความแตกต่างระหว่าง Monolith และ Layered อย่างชัดเจน
เข้าใจว่า Layered ช่วยในเรื่อง Maintainability แต่เพิ่ม Complexity
สามารถออกแบบ Layered Architecture เบื้องต้นได้
สัปดาห์ที่ 4: Architectural Styles & Patterns (2) - Microservices, Event-Driven, Service-Oriented, Serverlessวัตถุประสงค์

เข้าใจแนวคิดสถาปัตยกรรมสมัยใหม่
เรียนรู้ Microservices Architecture และ Event-Driven Architecture
รู้ว่าเมื่อไหร่ควร/ไม่ควรใช้ Microservices
เข้าใจ Serverless และ Service-Oriented Architecture
เนื้อหาภาคทฤษฎี (2 ชั่วโมง)1. Microservices Architectureคำจำกัดความ: สถาปัตยกรรมที่แบ่งระบบออกเป็น Services เล็ก ๆ อิสระ ที่แต่ละ Service ทำหน้าที่เฉพาะอย่างและสามารถ Deploy แยกกันได้แนวคิดหลัก:

Single Responsibility: แต่ละ Service ทำหน้าที่เดียว
Bounded Context: แต่ละ Service มี Domain เป็นของตัวเอง (จาก Domain-Driven Design)
Independent Deployment: Deploy แต่ละ Service ได้อิสระ
Decentralized Data: แต่ละ Service มี Database ของตัวเอง
Communication via API: สื่อสารกันผ่าน REST API, gRPC, หรือ Message Queue
โครงสร้างตัวอย่าง:
┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│   User       │      │   Board      │      │   Task       │
│   Service    │◄────►│   Service    │◄────►│   Service    │
│              │      │              │      │              │
│   DB: users  │      │  DB: boards  │      │   DB: tasks  │
└──────────────┘      └──────────────┘      └──────────────┘
       ▲                     ▲                     ▲
       │                     │                     │
       └─────────────────────┴─────────────────────┘
                             │
                    ┌────────▼────────┐
                    │   API Gateway   │
                    └─────────────────┘
                             ▲
                             │
                    ┌────────┴────────┐
                    │   Client App    │
                    └─────────────────┘องค์ประกอบสำคัญ:A. API Gateway:

เป็นจุดเข้าเดียวสำหรับ Clients
Routing requests ไป Service ที่เหมาะสม
Authentication/Authorization
Rate Limiting
Load Balancing
B. Service Discovery:

ช่วยให้ Services หากันเจอ (เพราะ IP อาจเปลี่ยน)
เครื่องมือ: Consul, Eureka, etcd
C. Circuit Breaker:

ป้องกันไม่ให้ Failure ของ Service หนึ่งกระทบ Service อื่น
หาก Service A เรียก Service B แล้ว B ล่ม Circuit Breaker จะ "เปิดวงจร" ไม่ให้เรียก B ชั่วคราว
D. Database per Service:

แต่ละ Service มี Database ของตัวเอง
ไม่แชร์ Database กัน (หลักการ Database Isolation)
ข้อดี:

Scalability: Scale แต่ละ Service แยกกันตาม Load
Technology Diversity: แต่ละ Service ใช้ Technology ต่างกันได้
Fault Isolation: Failure ของ Service หนึ่งไม่กระทบ Service อื่น
Independent Deployment: Deploy Service ใหม่โดยไม่ต้อง Deploy ทั้งระบบ
Team Autonomy: แต่ละทีมดูแล Service ของตัวเอง
ข้อเสีย:

Complexity สูง: มี Services จำนวนมาก ยากต่อการจัดการ
Distributed System Challenges:

Network Latency
Partial Failures
Data Consistency (CAP Theorem)
Debugging ยาก


Operational Overhead: ต้องจัดการ Deployment, Monitoring หลาย Services
Data Management: Transaction ข้าม Services ทำยาก
Testing: Integration Testing ซับซ้อน
เมื่อไหร่ควรใช้ Microservices:

✅ ระบบขนาดใหญ่และซับซ้อน
✅ ทีมพัฒนาหลายทีม (>50 คน)
✅ ต้องการ Scale แต่ละส่วนแยกกัน
✅ ต้องการ Technology Diversity
✅ องค์กรมีวุฒิภาวะด้าน DevOps
เมื่อไหร่ไม่ควรใช้ Microservices:

❌ Startup หรือทีมเล็ก
❌ ระบบไม่ซับซ้อน
❌ ไม่มีปัญหา Scalability
❌ ไม่มี DevOps Maturity
❌ Budget จำกัด
ตัวอย่างบริษัทที่ใช้ Microservices:

Netflix: มี 700+ Microservices
Amazon: มี 1000+ Microservices
Uber: แบ่งเป็น Services ตามฟีเจอร์
2. Event-Driven Architectureคำจำกัดความ: สถาปัตยกรรมที่ Components สื่อสารกันผ่าน Events (เหตุการณ์) แทนการเรียกกันโดยตรงแนวคิดหลัก:

Event: เหตุการณ์ที่เกิดขึ้นในระบบ (เช่น "UserRegistered", "TaskCompleted", "OrderPlaced")
Event Producer: Component ที่ส่ง Event
Event Consumer: Component ที่รับและประมวลผล Event
Event Bus/Broker: ตัวกลางที่รับและกระจาย Events
โครงสร้าง:
┌─────────────┐        ┌─────────────┐        ┌─────────────┐
│  Producer   │───────►│ Event Bus   │───────►│  Consumer   │
│  Service    │ Publish│ (Kafka/     │Subscribe│  Service    │
│             │        │  RabbitMQ)  │        │             │
└─────────────┘        └─────────────┘        └─────────────┘
                              │
                              ▼
                       ┌─────────────┐
                       │  Consumer   │
                       │  Service 2  │
                       └─────────────┘Patterns ใน Event-Driven:A. Pub/Sub (Publish-Subscribe):

Producer ส่ง Event ไปยัง Topic
Consumers Subscribe Topic ที่สนใจ
Consumers หลาย ๆ ตัวได้รับ Event เดียวกัน
ตัวอย่าง:
Event: "TaskCompleted"
Publisher: Task Service
Subscribers:
  - Notification Service (ส่ง Email)
  - Analytics Service (บันทึกสถิติ)
  - Reward Service (ให้คะแนน)B. Event Sourcing:

เก็บทุก Event ที่เกิดขึ้นในระบบ
สถานะปัจจุบัน = ผลรวมของ Events ทั้งหมด
สามารถ Replay Events เพื่อสร้างสถานะใหม่
ตัวอย่าง:
Events:
1. TaskCreated(id: 1, title: "Buy milk")
2. TaskAssigned(id: 1, user: "john")
3. TaskCompleted(id: 1, completedAt: "2024-01-01")

Current State = Apply all eventsC. CQRS (Command Query Responsibility Segregation):

แยก Model สำหรับ Write (Command) และ Read (Query)
Write Model → Event Sourcing
Read Model → Optimized for Queries
┌──────────┐      ┌──────────┐      ┌──────────┐
│ Command  │─────►│  Events  │─────►│  Query   │
│  Model   │ Write│  Store   │Update│  Model   │
└──────────┘      └──────────┘      └──────────┘ข้อดี:

Loose Coupling: Services ไม่ต้องรู้จักกัน
Scalability: Consumers สามารถเพิ่มได้
Resilience: Consumer ล่มไม่กระทบ Producer
Flexibility: เพิ่ม Consumer ใหม่ได้ง่าย
Audit Trail: มี Log ของทุก Events
ข้อเสีย:

Eventual Consistency: ข้อมูลอาจไม่สอดคล้องกันทันที
Debugging ยาก: ตาม Flow ของ Event ยาก
Event Order: ลำดับของ Events อาจเปลี่ยน
Event Schema Evolution: เปลี่ยน Event Format ยาก
เครื่องมือ:

Message Brokers: Apache Kafka, RabbitMQ, AWS SQS, Google Pub/Sub
Event Stores: EventStore, Postgres (with jsonb)
3. Service-Oriented Architecture (SOA)คำจำกัดความ: สถาปัตยกรรมที่แบ่งระบบเป็น Services ที่ให้บริการผ่าน Standard Protocols (เช่น SOAP, XML)ความแตกต่างระหว่าง SOA กับ Microservices:AspectSOAMicroservicesService Sizeใหญ่กว่าเล็กกว่าCommunicationSOAP, XML, ESBREST, gRPC, JSONData Sharingอาจแชร์ DatabaseDatabase แยกGovernanceCentralizedDecentralizedDeploymentIndependent (แต่ช้ากว่า)Independent (เร็วกว่า)FocusEnterprise IntegrationAgility & Speedโครงสร้างตัวอย่าง (SOA with ESB):
┌──────────┐      ┌──────────┐      ┌──────────┐
│ Service  │      │ Service  │      │ Service  │
│    A     │      │    B     │      │    C     │
└────┬─────┘      └────┬─────┘      └────┬─────┘
     │                 │                 │
     └─────────────────┼─────────────────┘
                       │
              ┌────────▼────────┐
              │ Enterprise      │
              │ Service Bus     │
              │     (ESB)       │
              └────────┬────────┘
                       │
              ┌────────▼────────┐
              │    Clients      │
              └─────────────────┘ESB (Enterprise Service Bus):

ตัวกลางที่จัดการการสื่อสารระหว่าง Services
ทำหน้าที่: Routing, Transformation, Orchestration
ข้อดี:

Enterprise Integration: เหมาะกับองค์กรใหญ่
Standard Protocols: ใช้ Standard ที่ยอมรับกันทั่วไป
Centralized Governance: ควบคุมจากจุดเดียว
ข้อเสีย:

ESB เป็น Bottleneck: ESB อาจเป็นจุดคอขวด
Complexity: ESB ซับซ้อน
Slow Deployment: Deploy ช้ากว่า Microservices
4. Serverless Architectureคำจำกัดความ: สถาปัตยกรรมที่นักพัฒนาไม่ต้องจัดการ Server โดยตรง เขียนแค่ Functions ที่รันตามเหตุการณ์ (Event)แนวคิดหลัก:

Function as a Service (FaaS): เขียนแค่ Function
Event-Driven: Function ถูกเรียกจาก Event
Auto-Scaling: Scale ตาม Load อัตโนมัติ
Pay-per-Use: จ่ายเฉพาะเวลาที่ Function ทำงาน
โครงสร้างตัวอย่าง:
┌───────────┐        ┌───────────┐        ┌───────────┐
│  Event    │───────►│ Function  │───────►│  Output   │
│  Source   │ Trigger│ (Lambda)  │ Write  │ (DB/S3)   │
└───────────┘        └───────────┘        └───────────┘

Event Sources:
- HTTP Request (API Gateway)
- File Upload (S3)
- Database Change (DynamoDB Streams)
- Schedule (CloudWatch Events)ตัวอย่าง Serverless Providers:

AWS Lambda
Google Cloud Functions
Azure Functions
Cloudflare Workers
Use Cases ที่เหมาะ:

Image Processing: ทุกครั้งที่มี Upload รูป ให้ Resize
Data Processing: ประมวลผลข้อมูลเมื่อมี Event
API Endpoints: REST API แบบง่าย ๆ
Scheduled Tasks: Cron Jobs, Background Jobs
Webhooks: รับ Webhook จาก External Services
ตัวอย่างโค้ด (AWS Lambda):
javascript// handler.js
exports.handler = async (event) => {
  // Event เช่น HTTP Request, S3 Upload, etc.
  console.log('Event:', JSON.stringify(event));
  
  // ประมวลผล
  const name = event.queryStringParameters?.name || 'World';
  
  // Return Response
  return {
    statusCode: 200,
    body: JSON.stringify({
      message: `Hello, ${name}!`
    })
  };
};ข้อดี:

ไม่ต้องจัดการ Server: Infrastructure จัดการให้
Auto-Scaling: Scale ตาม Load อัตโนมัติ
Cost-Effective: จ่ายแค่เมื่อใช้งาน
Fast Development: Focus แค่ Logic
High Availability: Provider จัดการให้
ข้อเสีย:

Cold Start: Function อาจต้องใช้เวลาในการเริ่มต้น (0.5-2 วินาที)
Vendor Lock-in: ติดกับ Provider
Timeout Limits: มีเวลาจำกัด (เช่น 15 นาที ใน AWS Lambda)
Debugging ยาก: ไม่มี Server ให้ SSH เข้าไปดู
State Management: ไม่มี Persistent State
เมื่อไหร่ควรใช้ Serverless:

✅ งานที่ Run เป็นครั้ง ๆ (ไม่ Continuous)
✅ Load ผันแปรมาก
✅ ต้องการ Development Speed สูง
✅ งบประมาณจำกัด
เมื่อไหร่ไม่ควรใช้ Serverless:

❌ งานที่ต้อง Run นาน ๆ (>15 นาที)
❌ ต้องการ Low Latency สม่ำเสมอ (เพราะ Cold Start)
❌ งานที่ต้องการ State Persistent
❌ ต้องการควบคุม Infrastructure เอง
เนื้อหาภาคปฏิบัติ (3 ชั่วโมง)กิจกรรม 1: ออกแบบ Task Board แบบ Microservices (90 นาที)วัตถุประสงค์: ให้นักศึกษาฝึกแบ่ง Monolithic System เป็น Microservicesขั้นตอน:ส่วนที่ 1: ระบุ Bounded Contexts (30 นาที)กิจกรรมกลุ่ม: แบ่งกลุ่ม ให้แต่ละกลุ่มระบุ Domain/Bounded Context ของ Task Board SystemDomain ที่เป็นไปได้:

User Management: จัดการผู้ใช้, Authentication
Board Management: จัดการ Boards, Lists
Task Management: จัดการ Tasks, Cards
Notification: แจ้งเตือนผู้ใช้
Activity Log: บันทึก Activities
Search: ค้นหา Tasks และ Boards
File Storage: เก็บไฟล์แนบ
ส่วนที่ 2: ออกแบบ Services (30 นาที)Microservices Design:
┌────────────────┐
│  API Gateway   │  ← Single Entry Point
└────────┬───────┘
         │
    ┌────┴────┬────────┬────────┬────────┐
    │         │        │        │        │
┌───▼───┐ ┌──▼──┐ ┌──▼──┐ ┌───▼────┐ ┌─▼──┐
│ User  │ │Board│ │Task │ │Notif.  │ │File│
│Service│ │Svc  │ │ Svc │ │Service │ │Svc │
└───┬───┘ └──┬──┘ └──┬──┘ └───┬────┘ └─┬──┘
    │        │       │        │        │
┌───▼───┐ ┌──▼──┐ ┌──▼──┐ ┌───▼────┐ ┌─▼──┐
│Users  │ │Boards│ │Tasks│ │Messages│ │S3  │
│  DB   │ │  DB  │ │  DB │ │ Queue  │ │    │
└───────┘ └──────┘ └──────┘ └────────┘ └────┘แต่ละ Service มีหน้าที่:1. User Service:

Authentication (Login/Logout)
User Registration
Profile Management
API: /api/users/*
Database: Users table
2. Board Service:

Create/Update/Delete Boards
Manage Board Members
API: /api/boards/*
Database: Boards, BoardMembers tables
3. Task Service:

Create/Update/Delete Tasks
Move Tasks between Lists
Assign Tasks to Users
API: /api/tasks/*
Database: Tasks, Lists tables
4. Notification Service:

Send Email/Push Notifications
Subscribe/Unsubscribe to Notifications
Listens to Events from other Services
Queue: RabbitMQ/Kafka
5. File Service:

Upload/Download Files
API: /api/files/*
Storage: AWS S3 / Google Cloud Storage
ส่วนที่ 3: วาดแผนภาพ (30 นาที)กิจกรรม: ให้แต่ละกลุ่มวาดแผนภาพ Microservices Architectureต้องแสดง:

Services ทั้งหมด
API Gateway
Communication Patterns (Sync/Async)
Databases
Message Queue (ถ้ามี)
กิจกรรม 2: Mini-Debate "Monolith ที่ดี vs Microservices ที่ไม่พร้อม" (60 นาที)วัตถุประสงค์: ให้นักศึกษาเข้าใจ Trade-offs และรู้ว่าเมื่อไหร่ควรใช้อะไรScenario: บริษัท Startup มีทีม 5 คน กำลังจะสร้าง Task Board System ใหม่แบ่งกลุ่มเป็น 2 ฝ่าย:ฝ่าย A: "เริ่มด้วย Monolith ดีกว่า"

ปกป้องว่า Monolith เหมาะกับ Startup
ข้อโต้แย้ง:

ทีมเล็ก พัฒนา Monolith เร็วกว่า
ไม่มีปัญหา Scalability ในตอนแรก
ไม่ต้องจัดการความซับซ้อนของ Distributed System
ประหยัดค่าใช้จ่าย


ฝ่าย B: "เริ่มด้วย Microservices ดีกว่า"

ปกป้องว่า Microservices เป็นอนาคต
ข้อโต้แย้ง:

Scale ได้ดีกว่าเมื่อโตขึ้น
Refactor จาก Monolith ไป Microservices ยากและเสียเวลา
แต่ละทีมทำงานอิสระได้
เทคโนโลยีที่ใช้ยืดหยุ่นกว่า


รูปแบบ Debate:

Opening Statement (5 นาที/ฝ่าย)
Rebuttal (5 นาที/ฝ่าย)
Q&A from Audience (10 นาที)
Closing Statement (3 นาที/ฝ่าย)
สรุปจากอาจารย์ (20 นาที):

ไม่มีคำตอบที่ถูกต้องเสมอไป
ต้องพิจารณาจาก Context:

ขนาดทีม
ความซับซ้อนของระบบ
งบประมาณ
Timeline
Technical Expertise


Monolith First: เริ่มด้วย Monolith แล้ว Refactor ไป Microservices ทีหลัง (ถ้าจำเป็น)
Modular Monolith: Monolith ที่ออกแบบเป็น Modules ชัดเจน แยกเป็น Microservices ได้ง่าย
กิจกรรม 3: Hands-on Lab - วาดแผนภาพการสื่อสาร Sync/Async (30 นาที)Scenario: User ลาก Task Card จาก List "TODO" ไปยัง "DONE"กิจกรรม: ให้นักศึกษาวาด Sequence Diagram แสดงการสื่อสารระหว่าง Servicesตัวอย่างผลลัพธ์:Synchronous Communication:
Client → API Gateway → Task Service → Board Service
                          ↓
                      Update Task Status
                          ↓
                       Return Success
                          ↓
       Client ← API Gateway ← Task ServiceAsynchronous Communication (with Event):
Client → API Gateway → Task Service
                          ↓
                    Update Task Status
                          ↓
                    Publish "TaskMoved" Event
                          ↓
                       Return Success
                          ↓
       Client ← API Gateway ← Task Service

(Background)
     Event Bus → Notification Service → Send Email
                → Activity Service → Log Activity
                → Analytics Service → Update Statsคำถามสำหรับอภิปราย:

Sync vs Async เหมาะกับ Use Case ไหนบ้าง?
ถ้าใช้ Async แล้ว Notification Service ล่ม จะเกิดอะไรขึ้น?
วิธีแก้ไขปัญหา Eventual Consistency คืออะไร?
ผลลัพธ์ที่คาดหวัง:

นักศึกษาเข้าใจความแตกต่างระหว่าง Synchronous และ Asynchronous
เห็น Use Cases ที่เหมาะสมของแต่ละแบบ
เข้าใจ Trade-offs ของ Microservices Architecture
สัปดาห์ที่ 5: C4 Model & Architecture Views (Context/Container)วัตถุประสงค์

เรียนรู้ C4 Model สำหรับการสร้างเอกสารสถาปัตยกรรม
ฝึกวาด C1 (System Context) และ C2 (Container Diagram)
เข้าใจการเลือก Viewpoint ที่เหมาะสมกับ Stakeholders
เนื้อหาภาคทฤษฎี (2 ชั่วโมง)1. ทำไมต้องมี Architecture Diagrams?ปัญหาของ Architecture Diagrams ทั่วไป:

ไม่มี Standard
แต่ละคนวาดต่างกัน
ไม่ระบุระดับของรายละเอียด (Abstract Level)
ไม่ชัดเจนว่าแต่ละกล่องคืออะไร (Server? Service? Module? Class?)
ความจำเป็น:

Stakeholders แต่ละกลุ่มต้องการรายละเอียดต่างกัน
CEO ไม่ต้องการเห็น Class Diagram
Developer ไม่ต้องการแค่ Big Picture
2. C4 Model คืออะไร?นิยาม: C4 Model เป็นแนวทางในการสร้าง Architecture Diagrams ที่มี 4 ระดับ (4 Levels of Abstraction)ผู้พัฒนา: Simon Brownแนวคิด: เหมือนการ Zoom ใน/ออก ของแผนที่

Level 1 (Context): ภาพรวมทั้งระบบ (Google Maps - ระดับประเทศ)
Level 2 (Container): แสดง Containers ภายในระบบ (Google Maps - ระดับเมือง)
Level 3 (Component): แสดง Components ภายใน Container (Google Maps - ระดับอาคาร)
Level 4 (Code): Class Diagram / ERD (Google Maps - ระดับห้อง)
3. C4 Level 1: System Context Diagramคำจำกัดความ: แสดงภาพรวมของระบบ และความสัมพันธ์กับ External Systems และ Usersองค์ประกอบ:

System (ระบบที่กำลังสร้าง): กล่องตรงกลาง
Person (ผู้ใช้งาน): Stick figures
External Systems: กล่องอื่น ๆ
สัญลักษณ์ใน C4:
┌─────────────┐
│   Person    │  ← Stick Figure หรือกล่อง
└─────────────┘

┌─────────────┐
│   System    │  ← กล่องสี่เหลี่ยม
│ [Software   │
│  System]    │
└─────────────┘

────────────►   ← ลูกศรแสดงความสัมพันธ์ (มี Label อธิบาย)ตัวอย่าง: Task Board System Context:
                     ┌──────────────┐
                     │  Team Member │
                     │   [Person]   │
                     └──────┬───────┘
                            │
                     Uses Task Board
                            │
              ┌─────────────▼─────────────┐
              │    Task Board System      │
              │  [Software System]        │
              │                           │
              │  Helps teams manage       │
              │  projects and tasks       │
              └─┬───────────────────────┬─┘
                │                       │
    Sends email │                       │ Stores files
                │                       │
    ┌───────────▼───────┐   ┌───────────▼──────────┐
    │  Email System     │   │  Cloud Storage       │
    │ [External System] │   │  [External System]   │
    │                   │   │                      │
    │  Sends notification│  │  AWS S3              │
    └───────────────────┘   └──────────────────────┘ใครควรดู Context Diagram:

CEO / CTO
Product Managers
Business Stakeholders
ใครก็ตามที่ต้องการเข้าใจระบบในภาพรวม
คำถามที่ Context Diagram ตอบได้:

ระบบนี้ทำอะไร?
ใครเป็นผู้ใช้งาน?
ระบบเชื่อมต่อกับระบบภายนอกอะไรบ้าง?
ขอบเขตของระบบคืออะไร?
4. C4 Level 2: Container Diagramคำจำกัดความ: แสดง Containers ภายในระบบ และความสัมพันธ์ระหว่างกันContainer คืออะไร:

ไม่ใช่ Docker Container
คือ: Application หรือ Data Store ที่ต้อง Deploy แยกกัน
ตัวอย่าง:

Web Application (React App)
API Server (Node.js)
Mobile App (iOS/Android)
Database (PostgreSQL)
Message Queue (RabbitMQ)


โครงสร้างของ Container:
┌──────────────────────┐
│   Container Name     │
│   [Technology]       │
│                      │
│   Description        │
└──────────────────────┘ตัวอย่าง: Task Board System Container Diagram:
                    ┌─────────────┐
                    │ Team Member │
                    └──────┬──────┘
                           │
                    Uses (HTTPS)
                           │
              ┌────────────▼───────────────┐
              │   Web Application          │
              │   [React SPA]              │
              │                            │
              │   Single Page Application  │
              │   for managing tasks       │
              └────────────┬───────────────┘
                           │
                    API Calls (JSON/HTTPS)
                           │
              ┌────────────▼───────────────┐
              │   API Application          │
              │   [Node.js + Express]      │
              │                            │
              │   Provides REST API        │
              │   and business logic       │
              └─┬──────────────────────┬───┘